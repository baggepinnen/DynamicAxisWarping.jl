# A cache to preallocate everything for the GDTW distance
struct GDTWWorkspace{T1, T2, T3}
    τ::T2
    l::T1
    u::T1
    l_prev::T1
    u_prev::T1
    l₀::T1
    u₀::T1
    min_costs::T2
    costs::T3
end

"""
    GDTWWorkspace{T}(M, N)

Creates a cache of numeric type `T` for use in [`gdtw`](@ref).
"""
function GDTWWorkspace{T}(M, N) where {T}
    GDTWWorkspace{Vector{T}, Matrix{T}, Array{T, 3}}(
        zeros(T, M, N), zeros(T, N), zeros(T, N),
        zeros(T, N), zeros(T, N), zeros(T, N),
        zeros(T, N), zeros(T, M, N), zeros(T, M, M, N)
    )
end

GDTWWorkspace(M, N) = GDTWWorkspace{Float64}(M, N)

# refine the bounds, as described in Section 4.2 of DB19
function refine!(l_current, u_current, l_prev, u_prev, l₀, u₀, warp; η)
    @inbounds for i in eachindex(l_current, u_current, l_prev, u_prev, l₀, u₀, warp)
        δ = η * (u_prev[i] - l_prev[i]) / 2
        l_current[i] = max(warp[i] - δ, l₀[i])
        u_current[i] = min(warp[i] + δ, u₀[i])
    end
    return nothing
end

# inital choices of `l` and `u`, as given in Eq (7) of DB19
function inital_bounds!(l, u, t, smin, smax)
    @inbounds for i in eachindex(t, l, u)
        l[i] = max(smin * t[i], 1 - smax * (1 - t[i]))
        u[i] = min(smax * t[i], 1 - smin * (1 - t[i]))
    end
    return nothing
end

# an inplace update to `τ` with the bounds `l` and `u`.
# produces `τ` as described in Section 4.1 of DB19.
function update_τ!(τ, t, M, l, u)
    N = length(t)
    @assert size(τ) == (M, N)
    @inbounds for t = 1:N, j = 1:M
        τ[j, t] = l[t] + ((j - 1) / (M - 1)) * (u[t] - l[t])
    end
    return nothing
end

"""
    gdtw(x, y; M::Int=100, N=nothing, t=range(0, stop=1, length=N), λcum=0.01,
    λinst=0.01, η=1 / 8, max_iters=3, metric=(x,y) -> norm(x-y),
    Rcum=u -> u * u, smin::Real=0.001, smax::Real=5.0,
    Rinst=u -> smin <= u <= smax ? u^2 : Inf,
    verbose=false,
    cache=GDTWWorkspace(M, N), warp=zeros(N))

Computes a general DTW distance following [DB19](https://arxiv.org/abs/1905.12893). The parameters are:

* `x`: the continuous time signal to warp (see [`LinearInterpolation`](@ref) for generating such a signal from discrete data)
* `y`: the continuous-time signal to warp to
* `t`: the discretization of time on `[0,1]`; either `t` or `N` should be specified
* `M`: the discretization of the values obtained by the warping path
* `metric`:  a function `metric(u,v) -> ℝ` to compute differences between the signals at a time point (such as a Distances.jl distance)
* `Rcum`: penalty function on the cumulative warp
* `Rinst`: penalty function on the instantaenous warping. Should be infinite outside of `[smin, smax]`.
* `smin`, `smax`: minimum and maximum allowed instantaenous warping. Should have `smin > 0` and `smin < smax`.
* `λcum`, `λinst`: the regularization constants for `Rcum` and `Rinst`, respectively

The following may be pre-allocated and reused between distance computations with the same `M` and `N` (or `length(t)`).

* `cache`: a cache of matrices and vectors, generated by `GDTW.GDTWWorkspace{Float64}(N,M)`

"""
gdtw(args...; kwargs...) = iterative_gdtw!(prepare_gdtw(args...; kwargs...))

"""
    prepare_gdtw(x, y; kwargs...)

Creates a NamedTuple of parameters, using the same keyword argments as `dist`.
A preprocessing step before calling `iterative_gdtw!`.
"""
function prepare_gdtw(x, y; M::Int=100, N=100, t = range(0, stop=1, length=N), λcum=0.01,
                      λinst=0.01, η=1 / 8, max_iters=3, metric=(x,y) -> norm(x-y),
                      Rcum=u -> u^2, smin::Real=0.001, smax::Real=5.0,
                      Rinst=u -> smin <= u <= smax ? u^2 : Inf,
                      verbose=false,
                      cache=GDTWWorkspace(M, length(t)), warp=zeros(length(t)),
                      callback=nothing)
    N = length(t)

    if !(M > N / smax)
        @warn "`M <= N / smax`; problem may be infeasible" M N smax
    end

    @unpack l₀, u₀, τ = cache
    inital_bounds!(l₀, u₀, t, smin, smax)

    update_τ!(τ, t, M, l₀, u₀)

    node_weight(j, s) = metric(x(τ[j, s]), y(t[s])) + λcum * Rcum(τ[j, s] - t[s])

    function edge_weight((j, s), (k, s2))
        s + 1 ≠ s2 && return Inf
        u = (τ[k, s+1] - τ[j, s]) / (t[s+1] - t[s])
        λinst * Rinst(u)
    end

    return (N=N, M=M, τ=τ, node_weight=node_weight, edge_weight=edge_weight,
            l₀=l₀, u₀=u₀, η=η, max_iters=max_iters, t=t, smin=smin, smax=smax,
            callback=callback, verbose=verbose, metric=metric, cache=cache,
            warp=warp)
end


function iterative_gdtw!(data)
    @unpack N, M, τ, η, max_iters, t, callback = data
    @unpack verbose, cache, warp = data

    if callback !== nothing
        callback((iter=1, t=t, τ=τ))
    end

    cost = single_gdtw!(data)

    max_iters == 1 && return cost, LinearInterpolation(warp, t)

    @unpack l_prev, u_prev, l, u, l₀, u₀ = cache
    l_prev .= l₀
    u_prev .= u₀
    u .= u₀
    l .= l₀
    iter = 2
    while iter <= max_iters
        if verbose
            @info "Iteration" iter cost
        end
        l, l_prev = l_prev, l
        u, u_prev = u_prev, u
        refine!(l, u, l_prev, u_prev, l₀, u₀, warp; η=η)
        update_τ!(τ, t, M, l, u)
        cost = single_gdtw!(data)
        if callback !== nothing
            callback((iter=iter, t=t, τ=τ, warp=warp, cost=cost))
        end
        iter += 1
    end
    return cost, LinearInterpolation(warp, t)
end

## Dynamic programming to compute the distance

function single_gdtw!(data::T) where {T}
    @unpack N, M, node_weight, cache, edge_weight, τ, warp = data
    @unpack min_costs, costs = cache
    calc_costs!(min_costs, costs, N, M, node_weight, edge_weight)
    cost = min_costs[end, end]
    trackback!(warp, costs, τ)
    return cost
end

function calc_costs!(min_costs, costs, N, M, node_weight::F1, edge_weight::F2) where {F1,F2}
    @boundscheck checkbounds(min_costs, 1:M, 1:N)
    @boundscheck checkbounds(costs, 1:M, 1:M, 1:N)

    @inbounds begin
        min_costs .= node_weight.(1:M, permutedims(1:N))
        # t = 2 case
        for j = 1:M
            costs[1, j, 2] = min_costs[1, 1] + edge_weight((1, 1), (j, 2))
            min_costs[j, 2] += costs[1, j, 2]
        end
        for t = 3:N
            for j = 1:M
                for k = 1:M
                    costs[k, j, t] = min_costs[k, t-1] + edge_weight((k, t - 1), (j, t))
                end
                min_costs[j, t] += minimum(@views costs[:, j, t])
            end 
        end
    end
    return nothing
end

function trackback!(warp, costs, τ)
    (M, _, N) = size(costs)
    @boundscheck checkbounds(costs, 1:M, 1:M, 1:N)
    c = M
    @inbounds for t = N:-1:3
        warp[t] = τ[c, t]
        c = argmin(@views costs[:, c, t])
    end
    warp[2] = τ[c, 2]
    warp[1] = τ[1, 1]

    return nothing
end

## Interpolations


"""
LinearInterpolation(x::AbstractVector) -> Function

Provides a linear interpolation of `x` on the interval `[0,1]`.
"""
struct LinearInterpolation{Tx,Tt} <: Function
    x::Tx
    t::Tt
    function LinearInterpolation(x::Tx, ts::Ts) where {Tx,Ts}
        @assert issorted(ts)
        t = (ts .- first(ts)) ./ ( last(ts) - first(ts))
        Tt = typeof(t)
        new{Tx,Tt}(x, t)
    end
end

LinearInterpolation(x) = LinearInterpolation(x, axes(x, ndims(x)))

function (xt::LinearInterpolation)(s)
    x = xt.x
    0 <= s <= 1 || return zero(x[!, 1])
    t = xt.t
    i = searchsortedlast(t, s)
    (i == 0) && return x[!, 1]
    (i == lastlength(x)) && return x[!, lastlength(x)]
    (s == t[i]) && return x[!, i]
    weight = (s - t[i]) / (t[i+1] - t[i])
    omw = 1 - weight
    x[!, i] .* omw .+ x[!, i+1] .* weight
end
